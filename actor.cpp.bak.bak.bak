#pragma once

BaseActor::BaseActor(DerivedBlock* l, const Shape* s, const MoveType* mt) : 
	HasShape(s), m_id(s_nextId++), m_name("actor#" + std::to_string(m_id)), m_moveType(mt), m_taskDelayCount(0)
{
	setLocation(l);
}
BaseActor::BaseActor(const Shape* s, const MoveType* mt) : 
	HasShape(s), m_id(s_nextId++), m_name("actor#" + std::to_string(m_id)), m_moveType(mt), m_taskDelayCount(0) { }
// Check location for route. If found set as own route and then register moving with area.
// Else register route request with area. Syncronus.
void BaseActor::setDestination(DerivedBlock& block)
{
	assert(&block != m_location);
	assert(block.anyoneCanEnterEver() && block.shapeAndMoveTypeCanEnterEver(m_shape, m_moveType));
	m_destination = &block;
	m_location->m_area->registerRouteRequest(static_cast<ACTOR&>(*this));
}
// nullptr is a valid value for block.
void BaseActor::setLocation(DerivedBlock* block)
{
	assert(block != m_location);
	assert(block->anyoneCanEnterEver() && block->shapeAndMoveTypeCanEnterEver(m_shape, m_moveType));
	assert(block->actorCanEnterCurrently(static_cast<ACTOR&>(*this)));
	block->enter(static_cast<ACTOR&>(*this));
}
BaseActor::~BaseActor()
{
	if(m_location != nullptr)
		m_location->m_area->m_locationBuckets.erase(static_cast<ACTOR&>(*this));
}
