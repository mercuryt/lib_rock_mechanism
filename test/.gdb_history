c
up
p fgMercury.m_stable
p fgMercury.m_drainQueue.m_queue
p fgMercury.m_fillQueue.m_queue
p fgMercury.m_excessVolume 
b Area::writeStep
c
r
p fgMercury->totalVolume()
up
p fgMercury->totalVolume()
c
up
p fgMercury->totalVolume()
p s_step
b Area::writeStep
c
r
p fgMercury->totalVolume()
up
p fgMercury->totalVolume()
c
up
c
up
p fgMercury->totalVolume()
p s_step
p fgMercury->m_excessVolume
c
p fgMercury->m_excessVolume
up
p fgMercury->m_excessVolume
p fgMercury->totalVolume()
p s_step
r
p s_step
c
p s_step
p fgMercury->totalVolume()
up
p fgMercury->totalVolume()
p area.m_fluidGroups.size()
c
up
p area.m_fluidGroups.size()
p fgMercury->totalVolume()
b Area::writeStep
c
r
p s_step
c
p s_step
up
p fgMercury->totalVolume()
r
up
p fgMercury->totalVolume()
c
up
p fgMercury->totalVolume()
p s_step
p fgMercury->m_drainQueue.m_queue
p fgMercury->m_fillQueue.m_queue
p fgMercury->m_fillQueue.m_queue[0].block->toS()
p fgMercury->m_fillQueue.m_queue[1].block->toS()
p fgMercury->m_fillQueue.m_queue[2].block->toS()
p fgMercury->m_fillQueue.m_queue[3].block->toS()
b FluidGroup::writeStep
r
up
up
p fgMercury->m_fillQueue.m_queue[3].block->toS()
down
p fgMercury->m_fillQueue.m_queue[3].block->toS()
p fgMercury->totalVolume()
c
up
p fgMercury->totalVolume()
c
up 2
p fgMercury->totalVolume()
c
up 2
p fgMercury->totalVolume()
c
up 2
p fgMercury->totalVolume()
r
c
p m_fluidType->name
up
p fgMercury->totalVolume()
p s_step
d
b FluidGroup::writeStep if s_step == 2
r
up 2
p fgMercury->totalVolume()
d
d
y
p fgMercury->totalVolume()
b FluidGroup::writeStep
up 2
p fgMercury->totalVolume()
down
p fgMercury->totalVolume()
down
p fgMercury->totalVolume()
r
p fgMercury->totalVolume()
up
p fgMercury->totalVolume()
up
p fgMercury->totalVolume()
p s_step
down
down
p m_fluidType->name
c
ce.
up
u
up
up
p m_fluidType->name
p fgMercury->totalVolume()
down
p m_fluidType->name
p s_step
c
up 2
p fgMercury->totalVolume()
down 2
p m_fluidType->name
p s_step
c
p m_fluidType->name
p s_step
up 2
p m_fluidType->name
p fgMercury->totalVolume()
c
up 2
p fgMercury->totalVolume()
d
b FluidGroup::writeStep if m_fluidType == s_Water
b FluidGroup::writeStep if m_fluidType == s_water
r
up 2
p fgMercury->totalVolume()
down 2
b FluidGroup::afterWriteStep if m_fluidType == s_water
r
c
up 2
p fgMercury->totalVolume()
b FluidGroup::splitStep if m_fluidType == s_water
c
up 2
p fgMercury->totalVolume()
b FluidGroup::mergeStep if m_fluidType == s_water
c
up 2
b FluidGroup::mergeStep if m_fluidType == s_water
p fgMercury->totalVolume()
down 2
p m_fluidType->name
p s_step
c
up 2
p fgMercury->totalVolume()
c
up 2
p fgMercury->totalVolume()
c
up 2
p fgMercury->totalVolume()
c
up 2
p fgMercury->totalVolume()
c
up 2
p fgMercury->totalVolume()
c
up 2
p fgMercury->totalVolume()
c
up 2
p fgMercury->totalVolume()
c
up 2
p fgMercury->totalVolume()
c
up 2
p fgMercury->totalVolume()
p s_step
d
b fluidGroup::writeStep if m_fluidType == s_water
b FluidGroup::writeStep if m_fluidType == s_water
r
p s_step
up 2
b FluidGroup::writeStep if m_fluidType == s_water
catch trow
catch throw
c
d 1
d 9
c
d 10
c
p s_step
p area.m_fluidGroups.size()
catch throw
r
p s_step
p area.m_fluidGroups.size()
p fgMercury->totalVolume()
catch throw
r
p expectedHeight
p totalBlocks2D 
p expectedBlocks
p 16 * 4
p 8*8
5/4
p 5/4
p 4/4
((4-1)/4)+1
p ((4-1)/4)+1
p ((5-1)/4)+1
p ((8-1)/4)+1
p ((9-1)/4)+1
r
p s_steps
p s_step
p fgWater->m_stable
p fgLava->m_stable
p fgMercury->m_stable
p fgCO2->m_stable
r
p area.m_fluidGroups[0]
p area.m_fluidGroups.begin()
p (area.m_fluidGroups.begin()+1)
r
p area.toS()
r
p area.toS()
set print elements 0
p area.toS()
r
p area.toS()
set print elements 0
p area.toS()
