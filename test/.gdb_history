p m_moveType->name
p block->moveTypeCanEnter(s_twoLegs)
r
p block->moveTypeCanEnter(s_twoLegs)
up 7
p block->moveTypeCanEnter(s_twoLegs)
r
up 7
p block->toS)
p block->toS()
p block->canStandIn()
r
up 7
p block->canStandIn()
p block->toS()
p block->adacents[5] == nullptr
p block->adacents[5] == 0
p block->adjacents[5] == 0
p block->m_adjacents[5]
p block->m_adjacents[5] == 0
p block->m_adjacents[5] == nullptr
p block->m_adjacents[5].isSolid()
p block->m_adjacents[5]->isSolid()
r
up 7
p block->toS()
p block->anyoneCanEnterEver ()
r
up 7
p block->toS()
p block->anyoneCanEnterEver ()
p block->moveTypeCanEnter(m_moveType)
p block->canStandIn
p block->canStandIn()
b testShared.h:271
r
p toS()
p adjacents[0]->toS()
p m_adjacents[0]->toS()
p m_adjacents[0]->hasFeatureType(s_upStairs)
p m_adjacents[0]->hasFeatureType(s_upDownStairs)
p m_adjacents[0]->toS()
r
r
r
r
r
up 7
p block->toS()
p block->anyoneCanEnterEver ()
p block->moveTypeCanEnter
p block->moveTypeCanEnter()
p block->moveTypeCanEnter(m_moveType)
p m_moveType
p m_moveType->name
whe
p block->m_features 
p m_moveType->canStandIn()
p block->canStandIn()
p block->toS()
p block->m_adjacents[0]
p block->m_adjacents[0]->isSolid()
p block->toS()
p block->m_adjacents[0]->toS()
r
r
r
whe
r
r
r
r
r
p area.m_blocks[2][2][1].moveTypeCanEnter(s_twoLegs)
p area.m_blocks[2][2][1].shapeAndMoveTypeCanEnterEver(s_twoByTwoFull, s_twoLegs)
b block.cpp:353
r
p block->toS()
p block->canStandIn ()
c
p block->canStandIn ()
p block->toS()
d
b block.cpp:353 if block->m_z == 1
r
p block->toS()
p block->m_area.m_sizeX
r
b block.cpp:353 if block->m_z == 1
r
p block->toS()
c
echo block->toS()
c
p block->toS()
p block
r
c
r
c
r
y
r
up
p area.m_blocks[2][2][1]->shapeAndMoveTypeCanEnterEver(s_twoByTwoFull, s_twoLegs)
p area.m_blocks[2][2][1].shapeAndMoveTypeCanEnterEver(s_twoByTwoFull, s_twoLegs)
r
p area.m_blocks[2][2][1].shapeAndMoveTypeCanEnterEver(s_twoByTwoFull, s_twoLegs)up
p area.m_blocks[2][2][1].shapeAndMoveTypeCanEnterEver(s_twoByTwoFull, s_twoLegs)
up
p area.m_blocks[2][2][1].shapeAndMoveTypeCanEnterEver(s_twoByTwoFull, s_twoLegs)
up
p area.m_blocks[2][2][1].shapeAndMoveTypeCanEnterEver(s_twoByTwoFull, s_twoLegs)
b testRoute.h:537
r
c
d 1
c
p area.m_blocks[2][2][1].shapeAndMoveTypeCanEnterEver(s_twoByTwoFull, s_twoLegs)
p actor.m_location->toS()
b block.cpp:353 if block->m_z == 1
p area.m_blocks[2][2][1].shapeAndMoveTypeCanEnterEver(s_twoByTwoFull, s_twoLegs)
r
c
d
b block.cpp:353 if block != 0 && block->m_z == 1
r
p block->toS()
d
b block.cpp:353 if block != 0 && block->m_z == 1 && block->m_solid == 0
r
b block.cpp:353 if block != 0 && block->m_z == 1 && block->m_solid == nullptr
b block.cpp:353 if block != 0 && block->m_z == 1
r
p block->toS()
n
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
c
p block->toS()
r
r
r
up
down
p area.m_blocks[2][2][1].shapeAndMoveTypeCanEnterEver(s_twoByTwoFull, s_twoLegs)
p area.m_blocks[2][1][1].shapeAndMoveTypeCanEnterEver(s_twoByTwoFull, s_twoLegs)
p area.m_blocks[1][1][1].shapeAndMoveTypeCanEnterEver(s_twoByTwoFull, s_twoLegs)
p area.m_blocks[4][1][1].shapeAndMoveTypeCanEnterEver(s_twoByTwoFull, s_twoLegs)
r
up 7
p block->toS()
p block->anyoneCanEnterEver ()
c
r
up 7
p block->anyoneCanEnterEver ()
p block->shapeAndMoveTypeCanEnterEver(m_shape, m_moveType)
b block.cpp:353 if block != 0 && block->m_z == 1
r
rr
r
b block.cpp:353 if block != 0 && block->m_z == 1
r
p block->toS()
c
p block->toS()
c
p block->toS()
b block.cpp:353 if block != 0 && block->m_z == 1 && !(block->m_x == 3 && block->m_y ==3)
d 1
c
p block
p block->toS()
c
p block->toS()
c
r
r
up 7
p block
p block->toS()
whe
p block->anyoneCanEnterEver ()
b block.cpp:353
c
r
p block
whe
c
whe
r
b block.cpp:353
r
p block->toS()
p block->canStandIn()
p block->m_adjacents[0]->hasFeatureType(s_ramp)
p block->m_adjacents[0]->toS()
r
r
r
r
r
r
r
r
r
r
up 7
p blockFeatureType->name
p block->m_features
p m_features
p block->toS()
whe
r
p a2->m_blocks
p a2->m_blocks[0]->toS()
p a2->m_blocks[1]->toS()
p a2->m_blocks[2]->toS()
p a2->m_blocks[3]->toS()
r
r
r
r
