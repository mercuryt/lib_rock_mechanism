TEST_CASE("Create Fluid.")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 1, s_stone);
	Block& block = area.m_blocks[5][5][1];
	block.setNotSolid();
	block.addFluid(100, s_water);
	CHECK(area.m_blocks[5][5][1].m_fluids.contains(s_water));
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	CHECK(fluidGroup->m_fillQueue.m_set.size() == 1);
	fluidGroup->readStep();
	CHECK(fluidGroup->m_stable);
	fluidGroup->writeStep();
	fluidGroup->mergeStep();
	std::vector<FluidGroup*> newlySplit;
	fluidGroup->splitStep(newlySplit);
	CHECK(!area.m_blocks[5][5][2].m_fluids.contains(s_water));
	CHECK(area.m_blocks[5][5][1].m_fluids.contains(s_water));
	CHECK(area.m_fluidGroups.size() == 1);
}
TEST_CASE("Excess volume spawns and negitive excess despawns.")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 2, s_stone);
	Block& block = area.m_blocks[5][5][1];
	Block& block2 = area.m_blocks[5][5][2];
	Block& block3 = area.m_blocks[5][5][3];
	block.setNotSolid();
	block2.setNotSolid();
	block.addFluid(MAX_BLOCK_VOLUME * 2, s_water);
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	CHECK(!fluidGroup->m_stable);
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 1);
	CHECK(fluidGroup->m_fillQueue.m_set.size() == 1);
	CHECK(fluidGroup->m_fillQueue.m_queue[0].block == &block2);
	// Step 1.
	fluidGroup->readStep();
	CHECK(!fluidGroup->m_stable);
	fluidGroup->writeStep();
	std::vector<FluidGroup*> newlySplit;
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(area.m_fluidGroups.size() == 1);
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 2);
	CHECK(fluidGroup->m_fillQueue.m_set.size() == 1);
	CHECK(fluidGroup->m_fillQueue.m_queue[0].block == &block3);
	CHECK(block2.m_fluids.contains(s_water));
	CHECK(block2.m_fluids[s_water].first == MAX_BLOCK_VOLUME);
	CHECK(fluidGroup == block2.m_fluids[s_water].second);
	// Step 2.
	fluidGroup->readStep();
	CHECK(fluidGroup->m_stable);
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(block2.m_fluids.contains(s_water));
	CHECK(!area.m_blocks[5][5][3].m_fluids.contains(s_water));
	block.removeFluid(MAX_BLOCK_VOLUME, s_water);
	CHECK(!fluidGroup->m_stable);
	// Step 3.
	fluidGroup->readStep();
	CHECK(fluidGroup->m_stable);
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(area.m_fluidGroups.size() == 1);
	CHECK(block.m_fluids.contains(s_water));
	CHECK(block.m_fluids[s_water].first == MAX_BLOCK_VOLUME);
	CHECK(!block2.m_fluids.contains(s_water));
}
TEST_CASE("Remove volume can destroy FluidGroups.")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 1, s_stone);
	Block& block = area.m_blocks[5][5][1];
	block.setNotSolid();
	block.addFluid(100, s_water);
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	fluidGroup->readStep();
	CHECK(fluidGroup->m_stable);
	fluidGroup->writeStep();
	std::vector<FluidGroup*> newlySplit;
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(area.m_fluidGroups.size() == 1);
	block.removeFluid(100, s_water);
	CHECK(fluidGroup->m_destroy == false);
	// Step 1.
	fluidGroup->readStep();
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 1);
	CHECK(fluidGroup->m_drainQueue.m_futureEmpty.size() == 1);
	CHECK(fluidGroup->m_destroy == true);
	area.writeStep();
	CHECK(area.m_unstableFluidGroups.empty());
	CHECK(area.m_fluidGroups.empty());
}
TEST_CASE("Flow into adjacent hole")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 2, s_stone);
	Block& destination = area.m_blocks[5][5][1];
	Block& block2 = area.m_blocks[5][5][2];
	Block& origin = area.m_blocks[5][6][2];
	Block& block4 = area.m_blocks[5][5][3];
	Block& block5 = area.m_blocks[5][6][3];
	std::vector<FluidGroup*> newlySplit;
	destination.setNotSolid();
	block2.setNotSolid();
	origin.setNotSolid();
	origin.addFluid(MAX_BLOCK_VOLUME, s_water);
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	CHECK(!fluidGroup->m_stable);
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 1);
	CHECK(fluidGroup->m_fillQueue.m_set.size() == 2);
	// Step 1.
	fluidGroup->readStep();
	CHECK(fluidGroup->m_destroy == false);
	CHECK(fluidGroup->m_fillQueue.m_set.size() == 2);
	CHECK(fluidGroup->m_fillQueue.m_set.contains(&block2));
	CHECK(fluidGroup->m_fillQueue.m_set.contains(&block5));
	CHECK(fluidGroup->m_futureRemoveFromFillQueue.empty());
	CHECK(fluidGroup->m_futureAddToFillQueue.size() == 3);
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(area.m_fluidGroups.size() == 1);
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 2);
	CHECK(!destination.m_fluids.contains(s_water));
	CHECK(block2.m_fluids.contains(s_water));
	CHECK(origin.m_fluids.contains(s_water));
	CHECK(origin.m_fluids[s_water].first == MAX_BLOCK_VOLUME / 2);
	CHECK(block2.m_fluids[s_water].first == MAX_BLOCK_VOLUME / 2);
	CHECK(fluidGroup->m_fillQueue.m_set.size() == 5);
	CHECK(fluidGroup->m_fillQueue.m_set.contains(&destination));
	CHECK(fluidGroup->m_fillQueue.m_set.contains(&block2));
	CHECK(fluidGroup->m_fillQueue.m_set.contains(&origin));
	CHECK(fluidGroup->m_fillQueue.m_set.contains(&block4));
	CHECK(fluidGroup->m_fillQueue.m_set.contains(&block5));
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 2);
	CHECK(fluidGroup->m_drainQueue.m_set.contains(&block2));
	CHECK(fluidGroup->m_drainQueue.m_set.contains(&origin));
	// Step 2.
	fluidGroup->readStep();
	CHECK(fluidGroup->m_futureRemoveFromFillQueue.size() == 4);
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(destination.m_fluids.contains(s_water));
	CHECK(!block2.m_fluids.contains(s_water));
	CHECK(!origin.m_fluids.contains(s_water));
	CHECK(destination.m_fluids[s_water].first == MAX_BLOCK_VOLUME);
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 1);
	// If the group is stable at this point depends on the viscosity of water, do one more step to make sure.
	CHECK(fluidGroup->m_fillQueue.m_set.size() == 1);
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 1);
	// Step 3.
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(area.m_fluidGroups.size() == 1);
	CHECK(fluidGroup->m_stable);
}
TEST_CASE("Flow across flat area")
{
	Area area(20,20,20);
	registerTypes();
	setSolidLayer(area, 0, s_stone);
	Block& block = area.m_blocks[10][10][1];
	Block& block2 = area.m_blocks[10][12][1];
	Block& block3 = area.m_blocks[11][11][1];
	Block& block4 = area.m_blocks[10][13][1];
	Block& block5 = area.m_blocks[10][14][1];
	Block& block6 = area.m_blocks[10][15][1];
	Block& block7 = area.m_blocks[16][10][1];
	Block& block8 = area.m_blocks[17][10][1];
	block.addFluid(MAX_BLOCK_VOLUME, s_water);
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	fluidGroup->readStep();
	fluidGroup->writeStep();
	std::vector<FluidGroup*> newlySplit;
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 5);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 20);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 0);
	for(Block* adjacent : block.m_adjacents)
		if(adjacent->m_z == 1)
			CHECK(adjacent->volumeOfFluidTypeContains(s_water) == 20);
	CHECK(!fluidGroup->m_stable);
	CHECK(fluidGroup->m_excessVolume == 0);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(area.m_fluidGroups.size() == 1);
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 13);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 9);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 25);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(!fluidGroup->m_stable);
	CHECK(fluidGroup->m_excessVolume == 25);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 41);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 18);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 61);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block7.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 39);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(area.m_fluidGroups.size() == 1);
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 85);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block7.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block8.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 15);
	fluidGroup->readStep();
	CHECK(fluidGroup->m_stable);
	CHECK(newlySplit.empty());
}
TEST_CASE("Flow across flat area double stack")
{
	Area area(20,20,20);
	registerTypes();
	setSolidLayer(area, 0, s_stone);
	Block& origin1 = area.m_blocks[10][10][1];
	Block& origin2 = area.m_blocks[10][10][2];
	Block& block1 = area.m_blocks[10][11][1];
	Block& block2 = area.m_blocks[11][11][1];
	Block& block3 = area.m_blocks[10][12][1];
	Block& block4 = area.m_blocks[10][13][1];
	Block& block5 = area.m_blocks[10][14][1];
	Block& block6 = area.m_blocks[15][10][1];
	Block& block7 = area.m_blocks[16][10][1];
	std::vector<FluidGroup*> newlySplit;
	origin1.addFluid(100, s_water);
	origin2.addFluid(100, s_water);
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	CHECK(area.m_fluidGroups.size() == 1);
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 2);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(area.m_fluidGroups.size() == 1);
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 5);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 40);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 40);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(!fluidGroup->m_stable);
	CHECK(fluidGroup->m_excessVolume == 0);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 13);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 15);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 15);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 15);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 15);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 5);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 25);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(!fluidGroup->m_stable);
	CHECK(fluidGroup->m_excessVolume == 25);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(area.m_fluidGroups.size() == 1);
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 41);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 4);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 4);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 4);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 4);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 4);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 36);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 61);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block7.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 17);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 85);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block7.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(fluidGroup->m_excessVolume == 30);
	CHECK(!fluidGroup->m_stable);
}
TEST_CASE("Flow across area and then fill hole")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 1, s_stone);
	Block& block = area.m_blocks[5][5][2];
	Block& block2a = area.m_blocks[5][6][2];
	Block& block2b = area.m_blocks[6][5][2];
	Block& block2c = area.m_blocks[5][4][2];
	Block& block2d = area.m_blocks[4][5][2];
	Block& block3 = area.m_blocks[6][6][2];
	Block& block4 = area.m_blocks[5][7][2];
	Block& block5 = area.m_blocks[5][7][1];
	Block& block6 = area.m_blocks[5][8][2];
	std::vector<FluidGroup*> newlySplit;
	block.addFluid(MAX_BLOCK_VOLUME, s_water);
	block5.setNotSolid();
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(area.m_fluidGroups.size() == 1);
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 5);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 20);
	CHECK(block2a.volumeOfFluidTypeContains(s_water) == 20);
	CHECK(block2b.volumeOfFluidTypeContains(s_water) == 20);
	CHECK(block2c.volumeOfFluidTypeContains(s_water) == 20);
	CHECK(block2d.volumeOfFluidTypeContains(s_water) == 20);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(!fluidGroup->m_stable);
	CHECK(fluidGroup->m_excessVolume == 0);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 13);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block2a.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block2b.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block2c.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block2d.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 9);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(area.m_fluidGroups.size() == 1);
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 1);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block2a.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 0);
	// If the group is stable at this point depends on the viscosity of water, do one more step to make sure.
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(fluidGroup->m_stable);
}
TEST_CASE("FluidGroups are able to split into parts")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 2, s_stone);
	Block& destination1 = area.m_blocks[5][4][1];
	Block& destination2 = area.m_blocks[5][6][1];
	Block& origin1 = area.m_blocks[5][5][2];
	Block& origin2 = area.m_blocks[5][5][3];
	std::vector<FluidGroup*> newlySplit;
	destination1.setNotSolid();
	destination2.setNotSolid();
	destination1.m_adjacents[5]->setNotSolid();
	destination2.m_adjacents[5]->setNotSolid();
	origin1.setNotSolid();
	origin1.addFluid(100, s_water);
	origin2.addFluid(100, s_water);
	CHECK(origin1.getFluidGroup(s_water) == origin2.getFluidGroup(s_water));
	CHECK(area.m_fluidGroups.size() == 1);
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	CHECK(fluidGroup->m_drainQueue.m_set.size() == 2);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 66);
	CHECK(destination1.m_adjacents[5]->volumeOfFluidTypeContains(s_water) == 66);
	CHECK(destination2.m_adjacents[5]->volumeOfFluidTypeContains(s_water) == 66);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	fluidGroup->splitStep(newlySplit);
	fluidGroup->mergeStep();
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(destination1.m_adjacents[5]->volumeOfFluidTypeContains(s_water) == 0);
	CHECK(destination2.m_adjacents[5]->volumeOfFluidTypeContains(s_water) == 0);
	CHECK(destination1.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(destination2.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(area.m_fluidGroups.size() == 2);
	CHECK(destination1.getFluidGroup(s_water) != destination2.getFluidGroup(s_water));
}
TEST_CASE("Fluid Groups merge")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 1, s_stone);
	Block& origin1 = area.m_blocks[5][4][1];
	Block& block1 = area.m_blocks[5][5][1];
	Block& origin2 = area.m_blocks[5][6][1];
	std::vector<FluidGroup*> newlySplit;
	origin1.setNotSolid();
	block1.setNotSolid();
	origin2.setNotSolid();
	origin1.addFluid(100, s_water);
	origin2.addFluid(100, s_water);
	CHECK(area.m_fluidGroups.size() == 2);
	FluidGroup* fg1 = origin1.getFluidGroup(s_water);
	FluidGroup* fg2 = origin2.getFluidGroup(s_water);
	CHECK(fg1 != fg2);
	// Step 1.
	fg1->readStep();
	fg2->readStep();
	fg1->writeStep();
	fg2->writeStep();
	fg1->splitStep(newlySplit);
	fg2->splitStep(newlySplit);
	fg1->mergeStep();
	fg2->mergeStep();
	CHECK(fg2->m_merged);
	CHECK(fg1->m_drainQueue.m_set.size() == 3);
	CHECK(fg1->m_excessVolume == 0);
	CHECK(fg1->m_fillQueue.m_set.size() == 6);
	CHECK(fg1->m_drainQueue.m_set.size() == 3);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(fg1 == origin1.getFluidGroup(s_water));
	CHECK(fg1 == block1.getFluidGroup(s_water));
	CHECK(fg1 == origin2.getFluidGroup(s_water));
	// Step 2.
	fg1->readStep();
	fg1->writeStep();
	fg1->splitStep(newlySplit);
	fg1->mergeStep();
	// Step 3.
	fg1->readStep();
	fg1->writeStep();
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 66);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 66);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 66);
	CHECK(fg1->m_excessVolume == 2);
	CHECK(fg1->m_stable);
}
TEST_CASE("Fluid Groups merge four blocks")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 1, s_stone);
	Block& block1 = area.m_blocks[5][4][1];
	Block& block2 = area.m_blocks[5][5][1];
	Block& block3 = area.m_blocks[5][6][1];
	Block& block4 = area.m_blocks[5][7][1];
	std::vector<FluidGroup*> newlySplit;
	block1.setNotSolid();
	block2.setNotSolid();
	block3.setNotSolid();
	block4.setNotSolid();
	block1.addFluid(100, s_water);
	block4.addFluid(100, s_water);
	CHECK(area.m_fluidGroups.size() == 2);
	FluidGroup* fg1 = block1.getFluidGroup(s_water);
	FluidGroup* fg2 = block4.getFluidGroup(s_water);
	CHECK(fg1 != fg2);
	// Step 1.
	fg1->readStep();
	fg2->readStep();
	fg1->writeStep();
	fg2->writeStep();
	fg1->splitStep(newlySplit);
	fg2->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(fg2->m_merged);
	fg2->mergeStep();
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 50);
	// Step 2.
	fg1->readStep();
	fg1->writeStep();
	fg1->mergeStep();
	fg1->splitStep(newlySplit);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(fg1->m_stable);
}
TEST_CASE("Denser fluids sink")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 2, s_stone);
	Block& block1 = area.m_blocks[5][5][1];
	Block& block2 = area.m_blocks[5][5][2];
	Block& block3 = area.m_blocks[5][5][3];
	std::vector<FluidGroup*> newlySplit;
	block1.setNotSolid();
	block2.setNotSolid();
	block1.addFluid(100, s_water);
	block2.addFluid(100, s_mercury);
	CHECK(area.m_fluidGroups.size() == 2);
	FluidGroup* fg1 = block1.getFluidGroup(s_water);
	FluidGroup* fg2 = block2.getFluidGroup(s_mercury);
	CHECK(fg1 != nullptr);
	CHECK(fg2 != nullptr);
	CHECK(fg1->m_fluidType == s_water);
	CHECK(fg2->m_fluidType == s_mercury);
	CHECK(fg1->m_fillQueue.m_set.size() == 1);
	// Step 1.
	fg1->readStep();
	CHECK(fg1->m_fillQueue.m_set.size() == 1);
	fg2->readStep();
	fg1->writeStep();
	CHECK(fg1->m_drainQueue.m_set.size() == 1);
	fg2->writeStep();
	fg1->splitStep(newlySplit);
	fg2->splitStep(newlySplit);
	CHECK(fg1->m_fillQueue.m_set.size() == 2);
	CHECK(fg1->m_fillQueue.m_set.contains(&block1));
	CHECK(fg1->m_fillQueue.m_set.contains(&block2));
	fg1->mergeStep();
	fg2->mergeStep();
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block1.volumeOfFluidTypeContains(s_mercury) == 50);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block2.volumeOfFluidTypeContains(s_mercury) == 50);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fg1->m_excessVolume == 50);
	CHECK(fg2->m_excessVolume == 0);
	CHECK(!fg1->m_stable);
	CHECK(!fg2->m_stable);
	CHECK(fg1->m_fillQueue.m_set.size() == 2);
	CHECK(fg1->m_fillQueue.m_set.contains(&block1));
	CHECK(fg1->m_fillQueue.m_set.contains(&block2));
	CHECK(fg2->m_fillQueue.m_set.size() == 3);
	// Step 2.
	fg1->readStep();
	fg2->readStep();
	fg1->writeStep();
	fg2->writeStep();
	fg1->splitStep(newlySplit);
	fg2->splitStep(newlySplit);
	fg1->mergeStep();
	fg2->mergeStep();
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block1.volumeOfFluidTypeContains(s_mercury) == 100);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block2.volumeOfFluidTypeContains(s_mercury) == 0);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fg1->m_excessVolume == 50);
	CHECK(fg2->m_excessVolume == 0);
	CHECK(!fg1->m_stable);
	CHECK(!fg2->m_stable);
	CHECK(fg1->m_fillQueue.m_set.size() == 3);
	CHECK(fg1->m_fillQueue.m_set.contains(&block1));
	CHECK(fg1->m_fillQueue.m_set.contains(&block2));
	CHECK(fg1->m_fillQueue.m_set.contains(&block3));
	CHECK(fg1->m_drainQueue.m_set.size() == 1);
	CHECK(fg1->m_drainQueue.m_set.contains(&block2));
	// Step 3.
	fg1->readStep();
	CHECK(fg1->m_futureGroups.size() == 0);
	fg2->readStep();
	fg1->writeStep();
	fg2->writeStep();
	fg1->splitStep(newlySplit);
	fg2->splitStep(newlySplit);
	fg1->mergeStep();
	fg2->mergeStep();
	CHECK(fg1->m_drainQueue.m_set.size() == 1);
	CHECK(fg1->m_fillQueue.m_set.size() == 2);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block1.volumeOfFluidTypeContains(s_mercury) == 100);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(block2.volumeOfFluidTypeContains(s_mercury) == 0);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fg1->m_stable);
	CHECK(fg1->m_excessVolume == 0);
	CHECK(fg2->m_excessVolume == 0);
	CHECK(fg2->m_stable);
	CHECK(newlySplit.empty());
}
TEST_CASE("Merge 3 groups at two block distance")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 1, s_stone);
	Block& block1 = area.m_blocks[5][2][1];
	Block& block2 = area.m_blocks[5][3][1];
	Block& block3 = area.m_blocks[5][4][1];
	Block& block4 = area.m_blocks[5][5][1];
	Block& block5 = area.m_blocks[5][6][1];
	Block& block6 = area.m_blocks[5][7][1];
	Block& block7 = area.m_blocks[5][8][1];
	std::vector<FluidGroup*> newlySplit;
	block1.setNotSolid();
	block2.setNotSolid();
	block3.setNotSolid();
	block4.setNotSolid();
	block5.setNotSolid();
	block6.setNotSolid();
	block7.setNotSolid();
	block1.addFluid(100, s_water);
	block4.addFluid(100, s_water);
	block7.addFluid(100, s_water);
	CHECK(area.m_fluidGroups.size() == 3);
	FluidGroup* fg1 = block1.getFluidGroup(s_water);
	FluidGroup* fg2 = block4.getFluidGroup(s_water);
	FluidGroup* fg3 = block7.getFluidGroup(s_water);
	CHECK(fg1 != nullptr);
	CHECK(fg2 != nullptr);
	CHECK(fg3 != nullptr);
	CHECK(fg1->m_fluidType == s_water);
	CHECK(fg2->m_fluidType == s_water);
	CHECK(fg3->m_fluidType == s_water);
	// Step 1.
	fg1->readStep();
	fg2->readStep();
	fg3->readStep();
	fg1->writeStep();
	fg2->writeStep();
	fg3->writeStep();
	fg1->splitStep(newlySplit);
	fg2->splitStep(newlySplit);
	fg3->splitStep(newlySplit);
	fg1->mergeStep();
	fg2->mergeStep();
	fg3->mergeStep();
	CHECK(fg1->m_drainQueue.m_set.size() == 7);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 33);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 33);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 33);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block7.volumeOfFluidTypeContains(s_water) == 50);
	// Step 2.
	fg1->readStep();
	fg1->writeStep();
	fg1->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 42);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 42);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 42);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 42);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 42);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 42);
	CHECK(block7.volumeOfFluidTypeContains(s_water) == 42);
	fg1->readStep();
	CHECK(fg1->m_stable);
}
TEST_CASE("Split test 2")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 4, s_stone);
	Block& block1 = area.m_blocks[5][4][1];
	Block& block2 = area.m_blocks[5][5][1];
	Block& block3 = area.m_blocks[5][5][2];
	Block& origin1 = area.m_blocks[5][5][3];
	Block& origin2 = area.m_blocks[5][6][3];
	Block& origin3 = area.m_blocks[5][7][3];
	Block& block4 = area.m_blocks[5][7][2];
	std::vector<FluidGroup*> newlySplit;
	origin1.setNotSolid();
	origin2.setNotSolid();
	origin3.setNotSolid();
	block1.setNotSolid();
	block2.setNotSolid();
	block3.setNotSolid();
	block4.setNotSolid();
	origin1.addFluid(20, s_water);
	FluidGroup* fg1 = origin1.getFluidGroup(s_water);
	origin2.addFluid(20, s_water);
	origin3.addFluid(20, s_water);
	CHECK(area.m_fluidGroups.size() == 1);
	CHECK(fg1->m_drainQueue.m_set.size() == 3);
	// Step 1.
	fg1->readStep();
	fg1->writeStep();
	fg1->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(fg1->m_excessVolume == 0);
	CHECK(fg1->m_drainQueue.m_set.size() == 1);
	CHECK(fg1->m_drainQueue.m_set.contains(&block3));
	FluidGroup* fg2 = block4.getFluidGroup(s_water);
	CHECK(fg2->m_drainQueue.m_set.size() == 1);
	CHECK(fg1 != fg2);
	CHECK(fg1->m_fillQueue.m_set.size() == 3);
	CHECK(area.m_fluidGroups.size() == 2);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(origin3.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 30);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 30);
	// Step 2.
	fg1->readStep();
	fg2->readStep();
	fg1->writeStep();
	fg2->writeStep();
	fg1->splitStep(newlySplit);
	fg2->splitStep(newlySplit);
	fg1->mergeStep();
	fg2->mergeStep();
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(origin3.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 30);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 30);
	CHECK(fg2->m_stable);
	// Step 3.
	fg1->readStep();
	fg1->writeStep();
	fg1->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 15);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 15);
	// Step 4.
	fg1->readStep();
	fg1->writeStep();
	fg1->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(fg1->m_stable);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 15);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 15);
}
TEST_CASE("Merge with group as it splits")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 4, s_stone);
	Block& origin1 = area.m_blocks[5][4][1];
	Block& block1 = area.m_blocks[5][5][1];
	Block& block2 = area.m_blocks[5][5][2];
	Block& origin2 = area.m_blocks[5][5][3];
	Block& origin3 = area.m_blocks[5][6][3];
	Block& origin4 = area.m_blocks[5][7][3];
	Block& block3 = area.m_blocks[5][7][2];
	std::vector<FluidGroup*> newlySplit;
	origin1.setNotSolid();
	origin2.setNotSolid();
	origin3.setNotSolid();
	origin4.setNotSolid();
	block1.setNotSolid();
	block2.setNotSolid();
	block3.setNotSolid();
	origin1.addFluid(100, s_water);
	FluidGroup* fg1 = origin1.getFluidGroup(s_water);
	origin2.addFluid(20, s_water);
	FluidGroup* fg2 = origin2.getFluidGroup(s_water);
	origin3.addFluid(20, s_water);
	origin4.addFluid(20, s_water);
	CHECK(area.m_fluidGroups.size() == 2);
	CHECK(fg1->m_drainQueue.m_set.size() == 1);
	CHECK(fg2->m_drainQueue.m_set.size() == 3);
	CHECK(fg1 != fg2);
	// Step 1.
	fg1->readStep();
	fg2->readStep();
	fg1->writeStep();
	CHECK(fg1->m_excessVolume == 0);
	fg2->writeStep();
	fg1->splitStep(newlySplit);
	fg2->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(fg2->m_merged);
	fg2->mergeStep();
	CHECK(fg1->m_drainQueue.m_set.size() == 3);
	FluidGroup* fg3 = block3.getFluidGroup(s_water);
	CHECK(fg3->m_drainQueue.m_set.size() == 1);
	CHECK(newlySplit.size() == 1);
	CHECK(newlySplit[0] == fg3);
	CHECK(fg2 != fg3);
	CHECK(fg1 != fg3);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(origin3.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(origin4.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 30);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 30);
	// Step 2.
	fg1->readStep();
	fg3->readStep();
	CHECK(fg1->m_excessVolume == 0);
	fg1->writeStep();
	CHECK(fg1->m_drainQueue.m_set.size() == 2);
	fg3->writeStep();
	fg1->splitStep(newlySplit);
	fg3->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(fg1->m_excessVolume == 0);
	fg3->mergeStep();
	CHECK(!fg3->m_merged);
	CHECK(fg3->m_stable);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 65);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 65);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 30);
	CHECK(fg1->m_stable);
}
TEST_CASE("Merge with two groups while spliting")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 4, s_stone);
	Block& origin1 = area.m_blocks[5][4][1];
	Block& block1 = area.m_blocks[5][5][1];
	Block& block2 = area.m_blocks[5][5][2];
	Block& origin2 = area.m_blocks[5][5][3];
	Block& origin3 = area.m_blocks[5][6][3];
	Block& origin4 = area.m_blocks[5][7][3];
	Block& block3 = area.m_blocks[5][7][2];
	Block& block4 = area.m_blocks[5][7][1];
	Block& origin5 = area.m_blocks[5][8][1];
	std::vector<FluidGroup*> newlySplit;
	origin1.setNotSolid();
	origin2.setNotSolid();
	origin3.setNotSolid();
	origin4.setNotSolid();
	origin5.setNotSolid();
	block1.setNotSolid();
	block2.setNotSolid();
	block3.setNotSolid();
	block4.setNotSolid();
	origin1.addFluid(100, s_water);
	FluidGroup* fg1 = origin1.getFluidGroup(s_water);
	origin2.addFluid(20, s_water);
	FluidGroup* fg2 = origin2.getFluidGroup(s_water);
	origin3.addFluid(20, s_water);
	origin4.addFluid(20, s_water);
	origin5.addFluid(100, s_water);
	FluidGroup* fg3 = origin5.getFluidGroup(s_water);
	CHECK(area.m_fluidGroups.size() == 3);
	CHECK(fg1 != fg2);
	CHECK(fg1 != fg3);
	CHECK(fg2 != fg3);
	// Step 1.
	fg1->readStep();
	fg2->readStep();
	fg3->readStep();
	CHECK(fg3->m_futureGroups.empty());
	fg1->writeStep();
	CHECK(fg1->m_excessVolume == 0);
	fg2->writeStep();
	fg3->writeStep();
	fg1->splitStep(newlySplit);
	fg2->splitStep(newlySplit);
	FluidGroup* fg4 = block3.getFluidGroup(s_water);
	CHECK(newlySplit.size() == 1);
	CHECK(newlySplit[0] == fg4);
	CHECK(!fg3->m_merged);
	fg3->splitStep(newlySplit);
	CHECK(fg1->m_drainQueue.m_set.size() == 2);
	CHECK(fg2->m_drainQueue.m_set.size() == 1);
	fg1->mergeStep();
	CHECK(fg1->m_drainQueue.m_set.size() == 3);
	CHECK(fg2->m_merged);
	fg2->mergeStep();
	fg4->mergeStep();
	fg3->mergeStep();
	CHECK(fg3->m_merged);
	CHECK(fg1->m_drainQueue.m_set.size() == 3);
	CHECK(fg4->m_drainQueue.m_set.size() == 3);
	CHECK(fg1 != fg4);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(origin3.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(origin4.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 30);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 30);
	CHECK(origin5.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 50);
	// Step 2.
	fg1->readStep();
	fg4->readStep();
	CHECK(fg1->m_excessVolume == 0);
	fg1->writeStep();
	CHECK(fg1->m_drainQueue.m_set.size() == 2);
	fg4->writeStep();
	fg1->splitStep(newlySplit);
	fg4->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(fg1->m_excessVolume == 0);
	fg4->mergeStep();
	CHECK(fg4->m_stable);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 65);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 65);
	CHECK(origin5.volumeOfFluidTypeContains(s_water) == 65);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 65);
	CHECK(fg1->m_stable);
}
TEST_CASE("Bubbles")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 4, s_stone);
	Block& origin1 = area.m_blocks[5][5][1];
	Block& origin2 = area.m_blocks[5][5][2];
	Block& origin3 = area.m_blocks[5][5][3];
	Block& block1 = area.m_blocks[5][5][4];
	std::vector<FluidGroup*> newlySplit;
	origin1.setNotSolid();
	origin2.setNotSolid();
	origin3.setNotSolid();
	block1.setNotSolid();
	origin1.addFluid(100, s_CO2);
	origin2.addFluid(100, s_water);
	origin3.addFluid(100, s_water);
	FluidGroup* fg1 = origin1.getFluidGroup(s_CO2);
	FluidGroup* fg2 = origin2.getFluidGroup(s_water);
	// Step 1.
	fg1->readStep();
	fg2->readStep();
	fg1->writeStep();
	fg2->writeStep();
	CHECK(fg1->m_excessVolume == 100);
	CHECK(fg1->m_disolved);
	fg2->splitStep(newlySplit);
	fg2->mergeStep();
	CHECK(origin1.volumeOfFluidTypeContains(s_CO2) == 0);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(origin2.volumeOfFluidTypeContains(s_CO2) == 0);
	CHECK(origin3.volumeOfFluidTypeContains(s_CO2) == 100);
	CHECK(fg1 == origin3.getFluidGroup(s_CO2));
	fg1->readStep();
	fg2->readStep();
	fg1->writeStep();
	fg2->writeStep();
	fg1->splitStep(newlySplit);
	fg2->splitStep(newlySplit);
	fg1->mergeStep();
	fg2->mergeStep();
	CHECK(fg1->m_stable);
	fg2->removeFluid(100);
	// Step 2.
	fg2->readStep();
	fg2->writeStep();
	CHECK(!fg1->m_stable);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 0);
	fg2->splitStep(newlySplit);
	fg2->mergeStep();
	// Step 3.
	fg1->readStep();
	CHECK(fg2->m_stable);
	fg1->writeStep();
	fg1->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(origin2.volumeOfFluidTypeContains(s_CO2) == 100);
	// Step 4.
	fg1->readStep();
	fg1->writeStep();
	CHECK(fg1->m_stable);
	CHECK(fg2->m_stable);
}
TEST_CASE("Three liquids")
{
	Area area(10,10,10);
	registerTypes();
	setSolidLayers(area, 0, 4, s_stone);
	Block& origin1 = area.m_blocks[5][5][1];
	Block& origin2 = area.m_blocks[5][5][2];
	Block& origin3 = area.m_blocks[5][5][3];
	Block& block1 = area.m_blocks[5][5][4];
	std::vector<FluidGroup*> newlySplit;
	origin1.setNotSolid();
	origin2.setNotSolid();
	origin3.setNotSolid();
	block1.setNotSolid();
	origin1.addFluid(100, s_CO2);
	origin2.addFluid(100, s_water);
	origin3.addFluid(100, s_mercury);
	FluidGroup* fg1 = origin1.getFluidGroup(s_CO2);
	FluidGroup* fg2 = origin2.getFluidGroup(s_water);
	FluidGroup* fg3 = origin3.getFluidGroup(s_mercury);
	// Step 1.
	fg1->readStep();
	fg2->readStep();
	fg3->readStep();
	fg1->writeStep();
	fg2->writeStep();
	CHECK(fg1->m_excessVolume == 100);
	CHECK(fg1->m_disolved);
	fg3->writeStep();
	fg2->splitStep(newlySplit);
	CHECK(fg1->m_excessVolume == 50);
	fg3->splitStep(newlySplit);
	fg2->mergeStep();
	fg3->mergeStep();
	CHECK(origin1.volumeOfFluidTypeContains(s_CO2) == 0);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(origin2.volumeOfFluidTypeContains(s_CO2) == 50);
	CHECK(origin2.volumeOfFluidTypeContains(s_mercury) == 50);
	CHECK(origin3.volumeOfFluidTypeContains(s_mercury) == 50);
	CHECK(fg1 == origin2.getFluidGroup(s_CO2));
	CHECK(fg1->m_excessVolume == 50);
	// Step 2.
	fg1->readStep();
	fg2->readStep();
	fg3->readStep();
	CHECK(!fg3->m_stable);
	fg1->writeStep();
	fg2->writeStep();
	fg3->writeStep();
	fg1->splitStep(newlySplit);
	fg2->splitStep(newlySplit);
	fg3->splitStep(newlySplit);
	fg1->mergeStep();
	fg2->mergeStep();
	fg3->mergeStep();
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(origin1.volumeOfFluidTypeContains(s_mercury) == 50);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(origin2.volumeOfFluidTypeContains(s_mercury) == 50);
	CHECK(origin2.volumeOfFluidTypeContains(s_CO2) == 50);
	CHECK(origin3.volumeOfFluidTypeContains(s_CO2) == 50);
	CHECK(origin3.volumeOfFluidTypeContains(s_mercury) == 0);
	CHECK(block1.m_totalFluidVolume == 0);
	CHECK(fg2->m_excessVolume == 50);
	CHECK(fg1->m_excessVolume == 0);
	// Step 3.
	newlySplit.clear();
	fg1->readStep();
	fg2->readStep();
	fg3->readStep();
	fg1->writeStep();
	fg2->writeStep();
	fg3->writeStep();
	fg1->splitStep(newlySplit);
	fg2->splitStep(newlySplit);
	fg3->splitStep(newlySplit);
	CHECK(newlySplit.empty());
	fg1->mergeStep();
	fg2->mergeStep();
	fg3->mergeStep();
	CHECK(origin1.volumeOfFluidTypeContains(s_mercury) == 100);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(origin2.volumeOfFluidTypeContains(s_mercury) == 0);
	CHECK(origin2.volumeOfFluidTypeContains(s_CO2) == 0);
	CHECK(origin3.volumeOfFluidTypeContains(s_CO2) == 50);
	CHECK(block1.m_totalFluidVolume == 0);
	CHECK(fg1->m_excessVolume == 50);
	CHECK(fg2->m_excessVolume == 50);
	// Step 4.
	newlySplit.clear();
	fg1->readStep();
	fg2->readStep();
	fg3->readStep();
	fg1->writeStep();
	fg2->writeStep();
	fg3->writeStep();
	fg1->splitStep(newlySplit);
	fg2->splitStep(newlySplit);
	fg3->splitStep(newlySplit);
	CHECK(newlySplit.empty());
	fg1->mergeStep();
	fg2->mergeStep();
	fg3->mergeStep();
	CHECK(fg2->m_stable);
	CHECK(origin1.volumeOfFluidTypeContains(s_mercury) == 100);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(origin3.volumeOfFluidTypeContains(s_CO2) == 50);
	CHECK(block1.m_totalFluidVolume == 0);
	CHECK(fg1->m_excessVolume == 50);
	CHECK(fg2->m_excessVolume == 0);
	CHECK(fg2->m_stable);
	CHECK(fg3->m_stable);
	// Step 5.
	fg1->readStep();
	fg1->writeStep();
	fg1->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(fg1->m_stable);
	CHECK(fg3->m_stable);
}
TEST_CASE("Set not solid")
{
	Area area(10, 10, 10);
	registerTypes();
	setSolidLayers(area, 0, 1, s_stone);
	Block& origin1 = area.m_blocks[5][5][1];
	Block& block1 = area.m_blocks[5][6][1];
	Block& block2 = area.m_blocks[5][7][1];
	std::vector<FluidGroup*> newlySplit;
	origin1.setNotSolid();
	block2.setNotSolid();
	origin1.addFluid(100, s_water);
	FluidGroup* fg1 = origin1.getFluidGroup(s_water);
	CHECK(fg1 != nullptr);
	// Step 1.
	fg1->readStep();
	fg1->writeStep();
	fg1->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(fg1->m_stable);
	// Step 2.
	block1.setNotSolid();
	CHECK(!fg1->m_stable);
	fg1->readStep();
	fg1->writeStep();
	fg1->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 50);
	// Step .
	fg1->readStep();
	fg1->writeStep();
	fg1->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 33);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 33);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 33);
	CHECK(!fg1->m_stable);
	CHECK(fg1->m_excessVolume == 1);
}
TEST_CASE("Set solid")
{
	Area area(10, 10, 10);
	registerTypes();
	setSolidLayers(area, 0, 1, s_stone);
	Block& origin1 = area.m_blocks[5][5][1];
	Block& block1 = area.m_blocks[5][6][1];
	Block& block2 = area.m_blocks[5][7][1];
	std::vector<FluidGroup*> newlySplit;
	origin1.setNotSolid();
	block1.setNotSolid();
	block2.setNotSolid();
	origin1.addFluid(100, s_water);
	FluidGroup* fg1 = origin1.getFluidGroup(s_water);
	// Step 1.
	fg1->readStep();
	fg1->writeStep();
	fg1->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(fg1->m_excessVolume == 0);
	block1.setSolid(s_stone);
}
TEST_CASE("Set solid and split")
{
	Area area(10, 10, 10);
	registerTypes();
	setSolidLayers(area, 0, 1, s_stone);
	Block& block1 = area.m_blocks[5][5][1];
	Block& origin1 = area.m_blocks[5][6][1];
	Block& block2 = area.m_blocks[5][7][1];
	std::vector<FluidGroup*> newlySplit;
	block1.setNotSolid();
	origin1.setNotSolid();
	block2.setNotSolid();
	origin1.addFluid(100, s_water);
	FluidGroup* fg1 = origin1.getFluidGroup(s_water);
	// Step 1.
	fg1->readStep();
	fg1->writeStep();
	fg1->splitStep(newlySplit);
	fg1->mergeStep();
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 33);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 33);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 33);
	CHECK(fg1->m_excessVolume == 1);
	// Step 2.
	origin1.setSolid(s_stone);
	CHECK(origin1.isSolid());
	CHECK(fg1->m_potentiallySplitFromSyncronusStep.size() == 2);
	CHECK(fg1->m_potentiallySplitFromSyncronusStep.contains(&block1));
	CHECK(fg1->m_potentiallySplitFromSyncronusStep.contains(&block2));
	CHECK(fg1->m_excessVolume == 34);
	fg1->readStep();
	fg1->writeStep();
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 50);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 50);
	fg1->splitStep(newlySplit);
	CHECK(newlySplit.size() == 1);
	CHECK(area.m_fluidGroups.size() == 2);
	FluidGroup* fg2 = &area.m_fluidGroups.back();
	fg1->mergeStep();
	fg2->mergeStep();
	CHECK(fg1->m_stable);
	//Step 3.
	fg2->readStep();
	CHECK(fg2->m_stable);
}
