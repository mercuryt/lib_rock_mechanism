TEST_CASE("Create Fluid.")
{
	Area area(100,100,100);
	registerTypes();
	setSolidLayers(area, 0, 1, s_stone);
	Block& block = area.m_blocks[50][50][1];
	block.m_solid = nullptr;
	block.addFluid(100, s_water);
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	fluidGroup->readStep();
	CHECK(fluidGroup->m_stable);
	fluidGroup->writeStep();
	CHECK(!area.m_blocks[50][50][2].m_fluids.contains(s_water));
}
TEST_CASE("Excess volume spawns and negitive excess despawns.")
{
	Area area(100,100,100);
	registerTypes();
	setSolidLayers(area, 0, 2, s_stone);
	Block& block = area.m_blocks[50][50][1];
	Block& block2 = area.m_blocks[50][50][2];
	block.m_solid = nullptr;
	block2.m_solid = nullptr;
	block.addFluid(MAX_BLOCK_VOLUME * 2, s_water);
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	CHECK(!fluidGroup->m_stable);
	fluidGroup->readStep();
	CHECK(!fluidGroup->m_stable);
	fluidGroup->writeStep();
	CHECK(block2.m_fluids.contains(s_water));
	uint32_t block2WaterVolume = block2.m_fluids[s_water].first;
	CHECK(block2WaterVolume == MAX_BLOCK_VOLUME);
	FluidGroup* fg = block2.m_fluids[s_water].second;
	CHECK(fluidGroup == fg);
	fluidGroup->readStep();
	CHECK(fluidGroup->m_stable);
	fluidGroup->writeStep();
	CHECK(block2.m_fluids.contains(s_water));
	CHECK(!area.m_blocks[50][50][3].m_fluids.contains(s_water));
	block.removeFluid(MAX_BLOCK_VOLUME, s_water);
	CHECK(!fluidGroup->m_stable);
	fluidGroup->readStep();
	CHECK(fluidGroup->m_stable);
	fluidGroup->writeStep();
	CHECK(block.m_fluids.contains(s_water));
	uint32_t blockWaterVolume = block.m_fluids[s_water].first;
	CHECK(blockWaterVolume == MAX_BLOCK_VOLUME);
	CHECK(!block2.m_fluids.contains(s_water));
}
TEST_CASE("Remove volume can destroy FluidGroups.")
{
	Area area(100,100,100);
	registerTypes();
	setSolidLayers(area, 0, 1, s_stone);
	Block& block = area.m_blocks[50][50][1];
	block.m_solid = nullptr;
	block.addFluid(100, s_water);
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	fluidGroup->readStep();
	CHECK(fluidGroup->m_stable);
	fluidGroup->writeStep();
	block.removeFluid(100, s_water);
	CHECK(fluidGroup->m_destroy == false);
	fluidGroup->readStep();
	CHECK(fluidGroup->m_futureBlocks.size() == 0);
	CHECK(fluidGroup->m_destroy == true);
	area.writeStep();
	CHECK(area.m_unstableFluidGroups.empty());
	CHECK(area.m_fluidGroups.empty());
}
TEST_CASE("Flow into adjacent hole")
{
	Area area(100,100,100);
	registerTypes();
	setSolidLayers(area, 0, 2, s_stone);
	Block& block = area.m_blocks[50][50][1];
	Block& block2 = area.m_blocks[50][50][2];
	Block& block3 = area.m_blocks[50][51][2];
	block.m_solid = nullptr;
	block2.m_solid = nullptr;
	block3.m_solid = nullptr;
	block3.addFluid(MAX_BLOCK_VOLUME, s_water);
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	CHECK(!fluidGroup->m_stable);
	fluidGroup->readStep();
	CHECK(fluidGroup->m_destroy == false);
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 2);
	CHECK(!block.m_fluids.contains(s_water));
	CHECK(block2.m_fluids.contains(s_water));
	CHECK(block3.m_fluids.contains(s_water));
	CHECK(block3.m_fluids[s_water].first == MAX_BLOCK_VOLUME / 2);
	CHECK(block2.m_fluids[s_water].first == MAX_BLOCK_VOLUME / 2);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(block.m_fluids.contains(s_water));
	CHECK(!block2.m_fluids.contains(s_water));
	CHECK(!block3.m_fluids.contains(s_water));
	CHECK(block.m_fluids[s_water].first == MAX_BLOCK_VOLUME);
	CHECK(fluidGroup->m_blocks.size() == 1);
	// If the group is stable at this point depends on the viscosity of water, do one more step to make sure.
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_stable);
}
TEST_CASE("Flow across flat area")
{
	Area area(100,100,100);
	registerTypes();
	setSolidLayer(area, 0, s_stone);
	Block& block = area.m_blocks[50][50][1];
	Block& block2 = area.m_blocks[50][52][1];
	Block& block3 = area.m_blocks[51][51][1];
	Block& block4 = area.m_blocks[50][53][1];
	Block& block5 = area.m_blocks[50][54][1];
	Block& block6 = area.m_blocks[50][55][1];
	Block& block7 = area.m_blocks[56][50][1];
	Block& block8 = area.m_blocks[57][50][1];
	block.addFluid(MAX_BLOCK_VOLUME, s_water);
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 5);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 20);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 0);
	for(Block* adjacent : block.m_adjacents)
		if(adjacent->m_z == 1)
			CHECK(adjacent->volumeOfFluidTypeContains(s_water) == 20);
	CHECK(!fluidGroup->m_stable);
	CHECK(fluidGroup->m_excessVolume == 0);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 13);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 9);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 25);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(!fluidGroup->m_stable);
	CHECK(fluidGroup->m_excessVolume == 25);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 41);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 18);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 61);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block7.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 39);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 85);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block7.volumeOfFluidTypeContains(s_water) == 1);
	CHECK(block8.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 15);
	CHECK(fluidGroup->m_stable);
}
TEST_CASE("Flow across flat area double stack")
{
	Area area(100,100,100);
	registerTypes();
	setSolidLayer(area, 0, s_stone);
	Block& origin1 = area.m_blocks[50][50][1];
	Block& origin2 = area.m_blocks[50][50][2];
	Block& block1 = area.m_blocks[50][51][1];
	Block& block2 = area.m_blocks[51][51][1];
	Block& block3 = area.m_blocks[50][52][1];
	Block& block4 = area.m_blocks[50][53][1];
	Block& block5 = area.m_blocks[50][54][1];
	Block& block6 = area.m_blocks[55][50][1];
	Block& block7 = area.m_blocks[56][50][1];
	origin1.addFluid(100, s_water);
	origin2.addFluid(100, s_water);
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	CHECK(area.m_fluidGroups.size() == 1);
	CHECK(fluidGroup->m_blocks.size() == 2);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 5);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 40);
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 40);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(!fluidGroup->m_stable);
	CHECK(fluidGroup->m_excessVolume == 0);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 13);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 15);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 15);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 15);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 15);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 5);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 25);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(!fluidGroup->m_stable);
	CHECK(fluidGroup->m_excessVolume == 25);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 41);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 4);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 4);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 4);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 4);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 4);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 36);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 61);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 3);
	CHECK(block7.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 17);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 85);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block1.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block2.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(block7.volumeOfFluidTypeContains(s_water) == 2);
	CHECK(fluidGroup->m_excessVolume == 30);
	CHECK(!fluidGroup->m_stable);
}
TEST_CASE("Flow across area and then fill hole")
{
	Area area(100,100,100);
	registerTypes();
	setSolidLayers(area, 0, 1, s_stone);
	Block& block = area.m_blocks[50][50][2];
	Block& block2a = area.m_blocks[50][51][2];
	Block& block2b = area.m_blocks[51][50][2];
	Block& block2c = area.m_blocks[50][49][2];
	Block& block2d = area.m_blocks[49][50][2];
	Block& block3 = area.m_blocks[51][51][2];
	Block& block4 = area.m_blocks[50][52][2];
	Block& block5 = area.m_blocks[50][52][1];
	Block& block6 = area.m_blocks[50][53][2];
	block.addFluid(MAX_BLOCK_VOLUME, s_water);
	block5.m_solid = nullptr;
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 5);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 20);
	CHECK(block2a.volumeOfFluidTypeContains(s_water) == 20);
	CHECK(block2b.volumeOfFluidTypeContains(s_water) == 20);
	CHECK(block2c.volumeOfFluidTypeContains(s_water) == 20);
	CHECK(block2d.volumeOfFluidTypeContains(s_water) == 20);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(!fluidGroup->m_stable);
	CHECK(fluidGroup->m_excessVolume == 0);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 13);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block2a.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block2b.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block2c.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block2d.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 7);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(fluidGroup->m_excessVolume == 9);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_blocks.size() == 1);
	CHECK(block.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block2a.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block3.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block4.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(block5.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(block6.volumeOfFluidTypeContains(s_water) == 0);
	// If the group is stable at this point depends on the viscosity of water, do one more step to make sure.
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(fluidGroup->m_stable);
}
TEST_CASE("FluidGroups are able to split into parts")
{
	Area area(100,100,100);
	registerTypes();
	setSolidLayers(area, 0, 2, s_stone);
	Block& destination1 = area.m_blocks[50][49][1];
	Block& destination2 = area.m_blocks[50][51][1];
	Block& origin1 = area.m_blocks[50][50][2];
	Block& origin2 = area.m_blocks[50][50][3];
	destination1.m_solid = nullptr;
	destination2.m_solid = nullptr;
	destination1.m_adjacents[5]->m_solid = nullptr;
	destination2.m_adjacents[5]->m_solid = nullptr;
	origin1.m_solid = nullptr;
	origin1.addFluid(100, s_water);
	origin2.addFluid(100, s_water);
	CHECK(origin1.getFluidGroup(s_water) == origin2.getFluidGroup(s_water));
	CHECK(area.m_fluidGroups.size() == 1);
	FluidGroup* fluidGroup = *area.m_unstableFluidGroups.begin();
	CHECK(fluidGroup->m_blocks.size() == 2);
	CHECK(fluidGroup->m_fillQueue.size() == 7);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(origin2.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 66);
	CHECK(destination1.m_adjacents[5]->volumeOfFluidTypeContains(s_water) == 66);
	CHECK(destination2.m_adjacents[5]->volumeOfFluidTypeContains(s_water) == 66);
	fluidGroup->readStep();
	fluidGroup->writeStep();
	CHECK(origin1.volumeOfFluidTypeContains(s_water) == 0);
	CHECK(destination1.m_adjacents[5]->volumeOfFluidTypeContains(s_water) == 0);
	CHECK(destination2.m_adjacents[5]->volumeOfFluidTypeContains(s_water) == 0);
	CHECK(destination1.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(destination2.volumeOfFluidTypeContains(s_water) == 100);
	CHECK(area.m_fluidGroups.size() == 2);
	CHECK(destination1.getFluidGroup(s_water) != destination2.getFluidGroup(s_water));
}
