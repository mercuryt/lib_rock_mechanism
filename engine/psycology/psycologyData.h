#pragma once
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wduplicated-branches"
#include "../../lib/Eigen/Dense"
#pragma GCC diagnostic pop
#include "../dataStructures/smallSet.h"
#include "../numericTypes/types.h"

class ActorIndex;
class Area;

enum class PsycologyAttribute
{
	Positivity,
	// When an actor is drafted and tries to enter a point where their enemies have more total threat or tries to path to same a low courage level will generate a FleeObjective.
	Courage,
	// High pride makes an actor more likely to reciprocate a ShoutAt objective, or possibly directly escalating to FistFight.
	Pride,
	// High community generates Conversation objectives.
	// Low community generates Isolation objectives.
	Community,
	// Anger events are generated from relationships.
	// Relationships with people usually generate a ShoutAt or FistFist objective. Sometimes a Murder objective.
	// Intensity is downgraded by high community.
	// Relationships with items may result in throwing or otherwise damaging the item.
	Anger,
	// High shame events generate Isolation objectives.
	// Low shame events generate Conversation objectives?
	Shame,
	Loyalty,
	// Low disipline may cause a worker to postpone their work queue.
	Discipline,
	// High greed events usually generate TheftByStealth and sometimes TheftByForce objectives.
	// They are generated by relationships with unowned items.
	// May be overiden by high Community or Loyalty.
	// Low greed events manifest as acts of charity.
	Greed,
	Respect,
	Null,
};

enum class FamilyRelationship
{
	Child,
	Mother,
	Father,
	Sibling,
	GrandParent,
	ChildOfSibling,
	SiblingOfParent,
	Cousine,
	ChildOfCousin,
	Other, // For more complex relationships like second cousine once removed.
	Null,
};
// A unique id for each source of psycological change.
enum class PsycologyEventType
{
	AccidentalHomicide,
	AccidentalSeriousInjury,
	Chastise,
	Chastised,
	Chat,
	Flee,
	InspirationalSpeach,
	LoseConfrontation,
	Praise,
	Praised,
	StandGround,
	WinConfrontation,
	Null,
};
// A SIMD alligned array of PsycologyWeights, one per PsycologyAttribute.
// Used by Psycology and PsycologyEvent.
struct PsycologyData
{
	static constexpr uint32_t capacity = (int)PsycologyAttribute::Null;
	Eigen::Array<float, 1, capacity> m_data;
	void operator+=(const PsycologyData& other);
	void operator-=(const PsycologyData& other);
	void operator*=(const float& scale);
	[[nodiscard]] PsycologyData operator-(const PsycologyData& other) const;
	void addTo(const PsycologyAttribute& attribute, const PsycologyWeight& value);
	void set(const PsycologyAttribute& attribute, const PsycologyWeight& value);
	void setAllToZero();
	[[nodiscard]] const PsycologyWeight getValueFor(const PsycologyAttribute& attribute) const;
	[[nodiscard]] bool anyAbove(const PsycologyData& other) const;
	[[nodiscard]] bool anyBelow(const PsycologyData& other) const;
	// TODO: We could use a bitmask instead of a small set here.
	[[nodiscard]] SmallSet<PsycologyAttribute> getAbove(const PsycologyData& other) const;
	[[nodiscard]] SmallSet<PsycologyAttribute> getBelow(const PsycologyData& other) const;
	NLOHMANN_DEFINE_TYPE_INTRUSIVE(PsycologyData, m_data);
};
/*
inline void to_json(Json& data, const PsycologyData& pData) { std::vector<float> vector; vector.reserve(PsycologyData::capacity); for(const float& weight : pData.m_data) vector.push_back(weight); data = vector; }
inline void from_json(const Json& data, PsycologyData& pData) { auto vector = data.get<std::vector<float>>(); for(int i = 0; i != PsycologyData::capacity; ++i) pData.m_data[i] = vector[i]; }
*/